(*  Translation of formulas into FOL

Translates formulas from Leo-II's term representation into
first-order formats, using different techniqes for encoding
type information.

Translations:
*  experiment
    Simply reimplements Leo-II's "fully-typed" translation.
    Intended to produce output identical the old "fully-typed"
    translation, but in the current framework.
*  experiment_improved
    Experimental tuning of the "experiment" translation.
*  tff_experiment
    Experimental TFF output.
*  fof_experiment and fof_full
    A big improvement on experiment_improved, closer to
    tff_experiment in design (and using more of its code).
    "fof_full" is fully-typed, while "fof_experiment"
    excludes monotonic types.

"experiment" and "experiment_improved" avoid early translation to
intermediate language. Early translation might require us
to duplicate or discard information relating to weights, age,
etc, which might be useful to the target prover.

"tff_experiment" and "fof_experiment" carry out early translation,
and this leads to more shared code (operating on values of the
intermediate translation) and a cleaner design.

Translation/printing functions are parametric on configuration,
to allow fine-grained control over presentation of the resulting
output (including syntactic features).

Care is taken to avoid collisions between uninterpreted constants,
interpreted_constants (defined in Signature) and special_symbols
(defined below), and any symbols a translation might create.

Translations may lambda-lift terms to create fresh first-order
combinators. Translations may also use term-level proxies for
formula-level constants (e.g. connectives); proxies may also
appear in the definitions of lifted combinators.

Among the FOF translations, FOF_Experiment tries hardest to transform
a problem into FO. The TFF translation will give up early if it
encounters abstractions (i.e. its input needs to be clearly FO).

TODO:
* Type/constant name prefixing needs to be done more carefully --
  for instance names could be distinguished by origin
  (i.e. original problem vs. generated by Leo2/translation).
* Package up "experiment" and "experiment_improved" translations,
   and the code they use exclusively. Move them elsewhere.
* Avoid encoding alpha-equivalent formulas
  (currently, identical formulas are not added to the
   FO formula cache, but this isn't strong enough)
* FOF: Determine minimum arity of functions.
* Add option for mangled type names.
* Add more type encodings.
* Add more output formats (e.g. DFG).
* Add infinity analysis.
*)

open General
open Translation_general
open App_term
open Translation_printing
open Af
open Hol_type
open Term


(*Adjusts type names by replacing them with proxies or prepending
  a prefix*)
let rec proximate_and_prefix_type = function
    Basetype s -> Basetype (proxy_basetype_for s)
  | Funtype (ty1, ty2) ->
      Funtype (proximate_and_prefix_type ty1,
               proximate_and_prefix_type ty2)


(* Translations' supporting functions *)

(*Tag a symbol with a type.*)
let ti ty t = Symbol tiK $ t $ type_to_term ty
let ti_at cfg ty ta = Const (tiK, ty) $$ [ta;
                                          type_to_term ty
                                          |> term_to_appterm cfg true []]

exception NO_PROXY of string

let proxy_symbol_of t = match t with
    Symbol "$true" -> "true"
  | Symbol "$false" -> "false"
  | Symbol "~" -> "not"
  | Symbol "|" -> "or"
  | Symbol "=" -> "equals"
  | Symbol "!" -> "forall"
  | _ -> raise (NO_PROXY (Term.to_string t))

let proxy_of_symbol s = proxy_symbol_of (Symbol s)

let proxable_consts =
  [Signature.ctrue; Signature.cfalse; Signature.neg;
   Signature.disjunction; Signature.forall; Signature.equality]
(*FIXME can remove this, to instead rely on NO_PROXY exception thrown by proxy_symbol_of*)
let is_proxable = function
    Const (s, _) -> List.mem s proxable_consts
  | _ -> raise (TRANSLATION "Nonsense argument")
let proxable_image = List.map proxy_of_symbol proxable_consts
let is_proxable_image = function
    Const (s, _) -> List.mem s proxable_image
  | _ -> raise (TRANSLATION "Nonsense argument")

let freshest_symbol = ref 0
let fresh_symbol () =
  freshest_symbol := 1 + !freshest_symbol;
  string_of_int !freshest_symbol

(*curried app_term appK-application*)
let rec ($$@@) f xs =
  match xs with
      [] -> f
    | x :: xs -> (f $@@ x) $$@@ xs

type lifted_combinator =
    string (*combinator's symbol*)
    * Hol_type.hol_type (*combinator's type*)
    * app_term (*combinator's defining axiom*)

(*maps string representations of formulas (i.e. naive, since not alpha factored)
  to unique names*)
let formula_register = Hashtbl.create ~random:false 10
(*returns cached name for formula if it exists,
  otherwise creates one and adds it to the register*)
let formula_name ?(prefix = "") ta =
  let ta_s = app_term_to_string ta
  in
    try
      Hashtbl.find formula_register ta_s
    with
      Not_found ->
        let name =
          if prefix = "" then
            raise (TRANSLATION "Prefix needed for formula name")
          else prefix ^ fresh_symbol ()
        in
          Hashtbl.add formula_register ta_s name;
          name

(*FIXME combine equivalent terms (e.g. identity function)
        rather than generate equivalent combinators*)
(*NOTE always use proxies in combinator definitions--this is done later on by proximate*)
let rec lambda_lift ((tr, _) as cfg : Translation_general.configuration) at_formula_level
    ta : app_term * lifted_combinator list =
  (*Generates lifted formulas of this form (where "is_fmla" indicates what kind of
    lifting is required):
      if is_fmla:     ! outer_vars. pK(fresh(outer_vars)) <=> (! inner_vars. fmla)
       otherwise:     ! outer_vars.    fresh(outer_vars)   =  fmla
    (i.e. when is_fmla=false, inner_vars is ignored. inner_vars is only ever
          used when lifting forall-quantified formulas)
    when is_fmla=true then result_type assumed to be Signature.bt_o*)
  let lift_term is_fmla result_type (outer_free_vars, outer_bnd_vars) inner_vars
      (lifted_ta, new_combinators) : app_term * lifted_combinator list =
    let fresh_f =
      formula_name ~prefix:(if is_fmla then prefix_lf else prefix_ll) ta in
    let ty =
      begin
        if is_fmla && result_type <> Signature.bt_o then
          raise (TRANSLATION "Formula must have Boolean result type")
        else
          List.fold_right
            (fun x y -> x @-> y)
            (List.map snd outer_free_vars)
            result_type
      end in
    let fresh_const = Const (fresh_f, ty) in
    let outer_vars = outer_free_vars @ outer_bnd_vars in
    (*this is what goes in the original (containing) term,
      where this term is being lifted from*)
    let combinator =
      if List.length outer_free_vars = 0 then fresh_const
      else
        fresh_const $$
          List.map (fun (s, ty) -> Var (s, ty)) outer_free_vars in
    (*This will be used as the LHS and it makes reference to
      the additional arguments it may be passed (i.e. outer_bnd_vars)
      NOTE we forall-quantify over all over_vars*)
    let definiendum =
      curried_app
        combinator
        (List.map (fun (s, ty) -> Var (s, ty)) outer_bnd_vars) in
    let new_combinator =
      if is_fmla then
        begin
        (*this should only be needed for specific translations*)
          assert (tr = TFF_Experiment || tr = FOF_Experiment);
          mk_quant Signature.forall outer_vars
            (iffK $$ [definiendum;
                      mk_quant Signature.forall inner_vars lifted_ta])
        end
      else
        mk_quant Signature.forall outer_vars
          (eqK $$ [definiendum;
                   lifted_ta])
    in (combinator,
        (fresh_f, ty, new_combinator) :: new_combinators) in
  match ta with
      Var _
    | Const _ -> (ta, [])
    | App (ta1, tas) ->
        (*check head to see if it's the marked for lifted equality;
          handle lifted equality specially, by lifting it into a fresh proposition*)
        if tr = TFF_Experiment || tr = FOF_Experiment &&
          check_head_const true (eq lift_marker_eq) ta1 then
          (*remove lifted-equality marker*)
          let ta1' = head_constname_to Signature.equality ta1 in
          (*now lift both slides of the equality*)
          let (lifted_tas, more_new_combinators) =
            map_fold (lambda_lift cfg
                        (at_formula_level &&
                           check_head_const false (is_iconstant false) ta1'))
              fst (snd @> List.append) [] tas
          in lift_term true Signature.bt_o (freevars_of ta, []) [] (App (ta1', lifted_tas), more_new_combinators)
        else if check_head_const false (eq (dest_Symbol leo2_forallK)) ta1 then
          (*!!-combinator appears as Const ("!",..) -- the !-quantifier appears as Quant("!",...)*)
          (*This instantiates a proxy axiom -- shape is similar to !-entry in "axioms_for_proxy_of"*)
          let ta' = List.hd tas in
          let arg_ty = type_of_appterm ta' |> Hol_type.dest_funtype |> fst in
          let var_x = "X"(*FIXME const, and not guaranteed to not capture*) in
          let ta'' =
            Quant ("!", [(var_x, arg_ty)],
                   App (ta', [Var (var_x, arg_ty)]))
          in
            lift_term true Signature.bt_o (freevars_of ta, []) []
              (lambda_lift cfg true(*since we're creating a new formula*) ta'')
        else
          let (lifted_ta', new_combinators) = lambda_lift cfg at_formula_level ta1 in
          let (lifted_tas, more_new_combinators) =
            map_fold (lambda_lift cfg
                        (at_formula_level &&
                           check_head_const false (is_iconstant false) lifted_ta'))
              fst (snd @> List.append) [] tas
          in (App (lifted_ta', lifted_tas), new_combinators @ more_new_combinators)
    | Abs (vars, ta') ->
        (*make axiom: !vars. fresh_f var_args = ta''
          where ta'' is lift of ta'*)
        lift_term false (type_of_appterm ta) (freevars_of ta, vars) []
          (lambda_lift cfg false(*since we're creating a new formula*) ta')
    | Quant (qtfr, vars, ta') ->
        if tr = ExperimentImproved (*ExperimentImproved doesn't have proper lifting*)
          || at_formula_level then
            let (lifted_ta', new_combinators) = lambda_lift cfg at_formula_level ta'
            in (Quant (qtfr, vars, lifted_ta'), new_combinators)
        else
          lift_term true Signature.bt_o (freevars_of ta, []) vars
            (lambda_lift cfg true(*since we're creating a new formula*) ta')

type proxy_symbols = string list
type clause_encoding = (string(*node name*) * app_term)
(*Full encoding encodes the resulting term (and the node name it's given),
  and combinator definitions and the proxy symbols used in both the formula
  and the combinator definitions.*)
type full_encoding = clause_encoding * proxy_symbols * lifted_combinator list

(*Transform a term to use proxies, and note which proxies are used
  (to insert their axioms later on)*)
(*NOTE when tr = ExperimentImproved proximate is only applied to lifted terms,
  since in that translation the proximation would already have taken place in
  clauses, before they were transformed to app_terms*)
(*NOTE this doesn't hold true for FOF_Experiment, since lifting/proximation
       is applied more uniformly on its formulas*)
let rec proximate ((tr, _) as cfg : Translation_general.configuration) at_formula_level (ta : app_term) : app_term * string list =
  match ta with
      Var _ -> (ta, [])
    | Const (s, ty) ->
        (*Using "is_iconstant" is too strong, since there
          aren't proxies for everything; so use is_proxable*)
        let (ta', proxies) =
          if is_proxable ta && (tr = ExperimentImproved (*ExperimentImproved doesn't have proper proximation*)
              || not at_formula_level) then
            (Const (proxy_of_symbol s, ty), [s])
          else (ta, [])
        in
          (ta', proxies)
    | App (ta1, tas) ->
        let tas_are_bools = List.for_all (type_of_appterm @> eq Signature.bt_o) tas in
        let (ta1', proxies) =
          if check_head_const false (eq (dest_Symbol leo2_eqK)) ta1 then
            (*check if = is being used as <=>; if so, change to <=>*)
            if at_formula_level && tas_are_bools then
              (iffK, [])
            else (*therefore = is being used as a predicate; might need to proximate*)
              if at_formula_level then
                (*leave "=" as is, and we'll proximate its arguments next*)
                (ta1, [])
              else
                (*"=" is appearing in a term, so lift/proximate*)
                if tr = ExperimentImproved then
                  (*in ExperimentImproved always proximate*)
                  let prox = proxy_of_symbol Signature.equality
                  in (Const (prox, dummy_type), [Signature.equality])
                else
                  (*otherwise proximate by lifting*)
                  let ty = dest_Const ta1 |> snd
                  in (Const (lift_marker_eq, ty), [])
          else proximate cfg at_formula_level ta1 in
        let (tas', tas_proxies) =
          map_fold (proximate cfg (at_formula_level &&
                                     ta1' <> eqK &&
                                     check_head_const false (is_iconstant false) ta1'))
            fst (snd @> List.append) [] tas
        in (ta1' $$ tas', proxies @ tas_proxies)
    | Abs (vars, ta') ->
        let (ta'', proxies) = proximate cfg false ta'
        in (Abs (vars, ta''), proxies)
    | Quant (qtfr, vars, ta') ->
        let (ta'', proxies) =
          if (tr = TFF_Experiment || tr = FOF_Experiment) &&
            not at_formula_level then
              (*we will lift this formula later on, and then assess how to proximate
                its subterms. Otherwise lifted formulas will be full of proxies for
                logical constants (when the actual constants might be used instead)*)
              (ta', [])
          else
            proximate cfg at_formula_level ta'
        in (Quant (qtfr, vars, ta''), proxies)

(*Lambda-lift an app-term, transform the lifted combinators to include proxies,
  and add the transformed combinators and their proxies to the accumulated
  output*)
let include_lambda_lifts ((tr, _) as cfg : Translation_general.configuration) ((n, ta), proxies) : full_encoding =
    if tr = Experiment then
      begin
        ((n, ta), [] (*i.e. ignore proxies*), [])
      end
    else if tr = ExperimentImproved || tr = TFF_Experiment || tr = FOF_Experiment then
      (*new_combinators contains definitions of any combinators which
        have been inserted into ta*)
      let (ta', new_combinators) = lambda_lift cfg true ta in
      (*exhaustively lift and proximate a set of (lifted) combinator definitions*)
      let rec iterate_thru new_combinators combinators proxies =
        match new_combinators with
            [] -> (combinators, proxies)
          | _ ->
              let (new_combinators', proxies') =
                List.map (fun (comb_name, comb_ty, comb_def) ->
                            let (comb_def', comb_proxies) = proximate cfg true comb_def
                            in ((comb_name, comb_ty, comb_def'), comb_proxies))
                  new_combinators
                  |> List.split
                  |> apsnd List.flatten in
              let (processed_combinators, new_combinators'') =
                List.map (fun (comb_name, comb_ty, comb_def) ->
                            let (comb_def', more_combinators) = lambda_lift cfg true comb_def
                            in ((comb_name, comb_ty, comb_def'), more_combinators)) new_combinators'
                |> List.split
                |> apsnd List.flatten
              in
                iterate_thru new_combinators'' (processed_combinators @ combinators) (proxies' @ proxies)(*FIXME inefficient, duplication*) in
      let (new_combinators', proxies') = iterate_thru new_combinators [] proxies
      in ((n, ta'), proxies', new_combinators')
    else raise (TRANSLATION "Not available for this translation")

(*Prefix all user-defined constants uniformly*)
let rec post_adjust_for_tff (cfg : Translation_general.configuration) (ta : app_term) : app_term =
  match ta with
      Var (s, ty) -> Var (s, proximate_and_prefix_type ty)
    | Const (s, ty) ->
        if is_uconstant true s && not (List.mem s proxies) then
          Const (prefix_const ^ s,
                 proximate_and_prefix_type ty)
        else ta
    | App (ta1, tas) ->
        let f = post_adjust_for_tff cfg
        in App (f ta1, List.map f tas)
    | Abs (vars, ta') ->
        Abs (vars, post_adjust_for_tff cfg ta')
    | Quant (qtfr, vars, ta') ->
        let check_var_for_firstorder (s, ty) =
          if is_funtype ty || ty = Signature.bt_o then
            raise (APP_TERM ("Higher order quantification", Var (s, ty)))
          else (s, ty)
        in Quant (qtfr, List.map check_var_for_firstorder vars,
                  post_adjust_for_tff cfg ta')

(*FIXME can this be made with other encodings, e.g. guards, too?*)
(*Mapping between particular constants and the proxies they give
  rise to. Nameclashes with "true" etc are avoided by having
  uniformly prefixed the constants appearing in the problem
  before calling this function.*)
(*NOTE this is used by Experiment and ExperimentImproved, since
       TFF_Experiment and FOF_Experiment just use the proxy names
       directly (then add their type declaration to the output)*)
let proxy_of ((tr, _) : Translation_general.configuration) t =
  let ti_symbol_for ty t = Some (ti ty (Symbol (proxy_symbol_of t)))
  in match t with
      Symbol "$true"
    | Symbol "$false" -> ti_symbol_for Signature.bt_o t
    | Symbol "~" ->
        if tr = Experiment then
          (*This is just to make Experiment's output identical to that
            of "fully-typed", since the latter uses the combinator "neg"
            whereas "not" is usually used in this module*)
          Some (ti (Signature.bt_o @-> Signature.bt_o) (Symbol "neg"))
        else
          ti_symbol_for (Signature.bt_o @-> Signature.bt_o) t
    | Symbol "|" -> ti_symbol_for (Signature.bt_o @-> (Signature.bt_o @-> Signature.bt_o)) t
    | Symbol "=" ->
        if tr = Experiment then raise (NO_PROXY (Term.to_string t))
        else ti_symbol_for (Signature.bt_i @-> Signature.bt_i @-> Signature.bt_o) t
    | Symbol "!" ->
        if tr = Experiment then raise (NO_PROXY (Term.to_string t))
        else ti_symbol_for (Signature.bt_o @-> Signature.bt_o) t
    | Symbol "^" -> raise (NO_PROXY (Term.to_string t))
    | Symbol _ -> None
    | _ -> raise (NO_PROXY (Term.to_string t))

let axioms_for_proxy_of ((tr, _) : Translation_general.configuration) s =
  let t = Symbol s in
    match tr with
        Experiment -> []
      | FOF_Experiment
      | ExperimentImproved ->
          (*FIXME encoding of type information should be parameter; currently
                  assuming full tags.*)
          (*FIXME can get ty value from signature*)
          let ti_symbol_for ty t = ti ty (Symbol (proxy_symbol_of t)) in
            begin
              match s with
                  "$true"
                | "$false" ->
                    [("1",
                      mk_iff t
                        (Symbol pK $ ti_symbol_for Signature.bt_o t))]
                | "~" -> (*! X. ~ (pK X) <=> pK(not X)*)
                    let (var_s, _) as var = ("X", Signature.bt_o) in
                    let ty = Signature.bt_o @-> Signature.bt_o
                    in
                      [("1",
                        mk_all [var]
                          (mk_iff (t $ (Symbol pK $ Symbol var_s))
                             (Symbol pK $ (ti_symbol_for ty t $@ Symbol var_s))
                          ))]
                | "|" -> (* ! X Y. (pK(X) | pK(Y)) <=> pK(X or Y) *)
                    let var_ty = Signature.bt_o in
                    let (var_x, var_y) = ("X", "Y") in
                    let ty = Signature.bt_o @-> Signature.bt_o @-> Signature.bt_o
                    in
                      [("1",
                        mk_all [(var_x, var_ty); (var_y, var_ty)]
                          (mk_iff (t $ (Symbol pK $ Symbol var_x) $ (Symbol pK $ Symbol var_y))
                             (Symbol pK $ (ti_symbol_for ty t $@ Symbol var_x $@ Symbol var_y))
                          ))]
                | "!" -> (*roughly ! P. pK(forall P) <=> ! X. pK(P @ X),
                           but we also quantify over types*)
                    let ty_var = "A" in
                    let (var_p, ty_p) = ("P", basetype ty_var @-> Signature.bt_o) in
                    let (var_x, ty_x) = ("X", basetype ty_var) in
                    let ty = ty_p @-> Signature.bt_o
                    in
                      [("1",
                        mk_all [(ty_var, Signature.bt_type); (var_p, ty_p)]
                          (mk_iff
                             (Symbol pK $ (ti_symbol_for ty t $@ Symbol var_p))
                             (mk_all [(var_x, ty_x)]
                                (Symbol pK $ (Symbol var_p $@ Symbol var_x))
                             )))]
                | "=" -> (*roughly ! X Y. X = Y <=> pK (X equal Y)
                           but we also quantify over types*)
                    (*test case: ![P:$o>$o,X:$i,Y:$i] : ((X=Y) = (Y=X))*)
                    let ty_var = "A" in
                    let ty_xy = basetype ty_var in
                    let (var_x, var_y) = ("X", "Y") in
                    let ti_var v = Symbol tiK $ Symbol v $ Symbol ty_var in
                    let ty = ty_xy @-> (ty_xy @-> Signature.bt_o)
                    in
                      [("1",
                        mk_all [(ty_var, Signature.bt_type); (var_x, ty_xy); (var_y, ty_xy)]
                          (mk_iff
                             (t $ Symbol var_x $ Symbol var_y)
                             (Symbol pK $
                                ti Signature.bt_o (ti (result_type ty) (ti_symbol_for ty t $@ ti_var var_x) $@
                                                     ti_var var_y))))]
                | _ -> raise (NO_PROXY (Term.to_string t))
            end
      | TFF_Experiment ->
          begin
            let proxy_t t = Symbol (proxy_symbol_of t)
            in match s with
                "$true" ->
                  [("1", Symbol pK $ proxy_t t)]
              | "$false" ->
                  [("1", mk_not (Symbol pK $ proxy_t t))]
              | "~" ->
                  (*! [F : o] : leoLit(not(X)) <=> ~(leoLit(X)) *)
                  let (var_f, var_ty) = ("F", Signature.bt_o)
                  in
                    [("1",
                      mk_all [(var_f, var_ty)]
                        (mk_iff
                           (Symbol pK $ (proxy_t t $ Symbol var_f))
                           (t $ (Symbol pK $ Symbol var_f))
                        ))]
              | "|" ->
                  (*! [F1 : o, F2 : o] : leoLit(or(F1, F2)) <=> leoLit(F1) | leoLit(F2)*)
                  let var_ty = Signature.bt_o in
                  let (var_f1, var_f2) = ("F1", "F2")
                  in
                    [("1",
                      mk_all [(var_f1, var_ty); (var_f2, var_ty)]
                        (mk_iff
                           (Symbol pK $ (proxy_t t $ Symbol var_f1 $ Symbol var_f2))
                           (t $ (Symbol pK $ Symbol var_f1) $ (Symbol pK $ Symbol var_f2))
                        ))]
              | "="
              | "!" ->
                  raise (TRANSLATION ("Proxy for " ^ s ^ " should not be required in this translation"))
              | _ -> raise (NO_PROXY (Term.to_string t))
          end
      | _ -> raise (TRANSLATION "Unimplemented")

(*Create strings representing terms. This is only used by Experiment*)
let rec string_term (cfg : Translation_general.configuration) (t : Term.term) : string =
  match cfg with
      (Experiment, _) ->
        (*ad hoc consts used locally, to emulate "fully-typed" translation*)
        let appl_const = "appl" in
        let abstr_const = "abstr" in
          begin
            match t with
                Symbol s ->
                  begin
                    try proxy_symbol_of t with
                        NO_PROXY _ -> s
                  end
              | Appl (t1, t2) -> appl_const ^ string_term cfg t1 ^ string_term cfg t2
                (*Note that we're not including "ty" below. This emulates the "fully-typed"
                  translation*)
              | Abstr (x, _, t') ->
                  abstr_const ^ string_term cfg x ^ string_term cfg t'
          end
    | _ -> raise (TRANSLATION "Not available for this translation")

(*This function is only used by Experiment and ExperimentImproved*)
(*Gives fully-typed encoding*)
let rec tag_term ((tr, _) as cfg : Translation_general.configuration) (t : Term.term) : Term.term * string list =
  assert (tr = Experiment || tr = ExperimentImproved); (* other translations works via a different pipeline *)
  let ty = Termsystem.type_of (Termsystem.term2xterm t) in
    match t with
        Symbol s ->
          begin
            match proxy_of cfg t with
                None ->
                  let t' =
                    if Translation_general.is_variable s then ti ty t
                    else if is_uconstant false s
                    then
                      if tr = Experiment then
                        (*Emulate Leo-II's "fully-typed" translation*)
                        ti ty t
                      else if tr = ExperimentImproved then
                        (*Prefix all uninterpreted constants, to mark their origin
                          from the problem file (as opposed to symbols introduced
                          as part of the translation*)
                        Symbol ((* FIXME add "prefix_const" ^ *) s)
                        |> ti ty
                      else
                        raise (TRANSLATION "Undefined for this translation")
                    else ti ty t
                  in (t', [])
              | Some p -> (p, [s])
          end
      | Appl (t1, t2) ->
          let (t1', t1_ps) = tag_term cfg t1 in
          let (t2', t2_ps) = tag_term cfg t2 in
            (ti ty (t1' $@ t2'), t1_ps @ t2_ps)
      | Abstr (x, ty', t') ->
          if tr = Experiment then
	          let new_abs_const = Symbol (string_term cfg t) in
	          let free_vars = Term.free_vars t in
              if free_vars = [] then
                (ti ty new_abs_const, [])
              else
                (List.map (function x -> Symbol x) free_vars
                 |> mk_app_from_list new_abs_const
                 |> ti ty, [])
          else
            (*add type info, since we won't have it later on*)
            let t_with_type = Abstr (Appl(x, type_to_term ty), ty', t') in
            (*let the abstraction through, we'll fix it later through lifting*)
            (t_with_type, [])

(*FIXME generalise to take other type_encodings as parameters?*)
(*FIXME instead of accumulating proxies every time, check whether the
        configuration actually requires them*)
(*Apply tag_term to each literal's term*)
let tag_clause (cfg : Translation_general.configuration) (d : decoration_pred) (cl : Clause.cl_clause) : Clause.cl_clause * string list =
  (*Let top-level predicates stay if = or !=, otherwise add pK tag*)
  let make_pred t = match t with
      Appl (Appl (Symbol "=" as c, t1), t2)
    | Appl (Appl (Symbol "!=" as c, t1), t2) ->
        let (t1', t1_prox) = tag_term cfg t1 in
        let (t2', t2_prox) = tag_term cfg t2 in
          (c $ t1' $ t2', t1_prox @ t2_prox)
    | _ ->
        let (t1', t1_prox) = tag_term cfg t in
          (Symbol pK $ t1', t1_prox) in
  let tag_literal (l : Clause.role Literal.lit_literal) =
    let (t1', t1_prox) = make_pred (Termsystem.xterm2term l.Literal.lit_term) in
      ({l with Literal.lit_term = Termsystem.term2xterm (t1')},
       t1_prox) in
  let (ls', ps) =
    map_fold tag_literal fst (fun (_, x) l -> x :: l) [] (Array.to_list cl.Clause.cl_litarray)
  in
    ({cl with Clause.cl_litarray = Array.of_list ls'}, List.flatten ps)

(*wrap terms in pK, to simulate literals, if they are typed with the proxy
  type for $o (i.e. they are proxies (lifts of connectives) or other lifts)
  pK_wrap will only descend to the point where there is an $o-typed uninterpreted
  symbol (i.e. it will not descend into terms)*)
let rec pK_wrap (cfg : Translation_general.configuration) (ta : app_term) : app_term =
  match ta with
      Var (_, ty) ->
        assert (ty = Signature.bt_o);
        mk_pK_app ta
    | Const (s, ty) ->
        assert (ty = Signature.bt_o);
        if is_iconstant false s then
          begin
            assert (s = Signature.ctrue ||
                s = Signature.cfalse);
            ta
          end
        else
          mk_pK_app ta
    | App (ta1, tas) ->
        (*if ta1 is interpreted then recurse (unless ta1="=")
          else
            (ta1 is uninterpreted)
            if ta1 is $o-valued then pK_wrap whole ta,
            (else throw exception -- we shouldn't be here)*)
        if check_head_const true (is_iconstant false) ta1 then
          (*at this point we have already distinguished "=" from "<=>" using proximate*)
          if check_head_const true (eq Signature.equality) ta1 then
            ta
          else
            App (ta1, List.map (pK_wrap cfg) tas)
        else
          begin
            (*ta's head is uninterpreted constant, or a translation combinator, or a variable*)
            assert (check_head_const true (is_uconstant false) ta1 ||
                      default false (head_of @> dest_Var @> (fun _ -> true)) ta1);
            assert (type_of_appterm ta = Signature.bt_o);
            mk_pK_app ta
          end
    | Abs _ ->
        raise (TRANSLATION "Abstractions should have been removed at this point")
    | Quant (qtfr, vars, ta') ->
        assert (type_of_appterm ta = Signature.bt_o);
        Quant (qtfr, vars, pK_wrap cfg ta')

(*Wraps certain terms in tiK, and makes application explicit through appK.
  The "d" predicate determines which types need tagging.*)
(*NOTE if d = \x.True then get fully-typed tagged encoding*)
let rec tag_app_term (cfg : Translation_general.configuration) (d : decoration_pred) at_formula_level (ta : app_term) : app_term =
  (*curried app_term appK-application with tagging*)
  (*"f x1 x2 .. xn" =>  "appK(..appK(appK(f, x1) x2).., xn)", with tiK's as appropriate *)
  (*NOTE [f, x1, ..., xn] should already be tagged individually
         Tagging is introduced for each term appK(x, y) if d(x(y))=true*)
  let rec ($$@@) f xs =
    match xs with
        [] -> f (*"f" should already have been tagged if necessary*)
      | x :: xs ->
          let pre_fx = f $@@ x in
          let ty_fx = type_of_appterm pre_fx in (*recall that "$@@" types appK*)
          let fx =
            if d ty_fx then
              ti_at cfg ty_fx pre_fx
            else
              pre_fx
          in
            fx $$@@ xs in
  let ty = type_of_appterm ta in
    match ta with
        Var _ ->
          if check_head_const true (eq tiK) ta then
            (*don't wrap tiK in tiK*)
            ta
          else
            ?! (d ty) (ti_at cfg ty) ta
      | Const (s, ty) ->
          if check_head_const true (eq tiK) ta then
            (*don't wrap tiK in tiK*)
            ta
          else
            ?! (is_uconstant false s)
              (?! (d ty) (ti_at cfg ty)) ta
      | App (ta1, tas) ->
          let tagger = tag_app_term cfg d
          in
            if check_head_const true (eq appK) ta1 then
              begin
                IFDEF DEBUG THEN
                  assert (not at_formula_level);
                END;
                (*if head const is appK then tag it, but don't wrap it in appK*)
                ti_at cfg ty (ta1 $$ List.map (tagger false) tas)
              end
            else if check_head_const true (eq Signature.equality) ta1 then
              (*No need to handle "!=" since it has been expanded away*)
              begin
                IFDEF DEBUG THEN
                  assert at_formula_level; (*if ta1="=" and at_formula_level=false then = should have been proximated*)
                END;

                if List.exists (check_head_const false (is_iconstant false)) tas ||
                  (*don't forget quantifiers*)
                  List.exists (default false (dest_Quant @> (fun _ -> true))) tas then
                    (*could change to "iffK $$ List.map (tagger true) tas", but
                      that was proximate's job*)
                    raise (TRANSLATION "Proximate failed to lift equality")
                else
                  begin
                    ta1 $$ List.map (tagger false) tas
                  end
              end
            else if check_head_const true (is_iconstant true) ta1 then
              (*if head const is a logical/special const then don't tag it, and don't wrap it in appK*)
              if not ((head_of @> dest_Const @> fst @> is_iconstant false) ta1) then
                (*head must be special_symbol. we have already handled the case where ta1=appK.
                  so ta1 must be tiK*)
                begin
                  IFDEF DEBUG THEN
                    assert (check_head_const true (eq tiK) ta1);
                  END;
                  ta1 $$ List.map (tagger false) tas
                end
              else
                (*must be a logical constant. don't wrap it in tiK or use appK, but
                  check its arguments*)
                ta1 $$ List.map (tagger true) tas
            else
              (*must be an uninterpreted constant*)
              begin
                (*we assume that at_formula_level=false at this term's level,
                  since if currently at_formula_level=true we'll wrap it in pK,
                  therefore making at_formula_level=false*)
                tagger false ta1 $$@@ List.map (tagger false) tas
              end
      | Abs _ ->
          raise (TRANSLATION "Lifting failed to remove abstractions")
      | Quant (qtfr, vars, ta') ->
          if not at_formula_level then
            raise (TRANSLATION "Cannot have quantifier at term-level");
          Quant (qtfr, vars, tag_app_term cfg d at_formula_level ta')

(*Rename constant names, prefixing them with prefix_const.
  This avoids clashes in case a problem contains constants with same name
  as proxy names, for example.*)
(*FIXME not tail recursive*)
let rec offset_constnames t =
  match t with
      Symbol s ->
        let s' =
          if Translation_general.is_variable s || List.mem s Signature.interpreted_constants then s
          else prefix_const ^ s
        in Symbol s'
    | Appl (t1, t2) -> Appl (offset_constnames t1, offset_constnames t2)
    | Abstr (ts, ty, t') -> Abstr (ts, ty, offset_constnames t')

(*Returns pairs consisting of clause name and the term representing
  the whole clause. If input clause has already been processed to
  include type info, don't reapply processing to the term produced
  by this function.*)
let clause_to_term ((tr, _) : Translation_general.configuration)
    (cl : Clause.cl_clause) : string * Term.term =
  let literal_to_term (l : Clause.role Literal.lit_literal) : Term.term =
    let t = offset_constnames (Termsystem.xterm2term l.Literal.lit_term) in
    if l.Literal.lit_polarity then t
    else mk_not t in
  let free_vars =
    List.map
     (function t -> (dest_Symbol t, Termsystem.type_of (Termsystem.term2xterm t)))
     cl.Clause.cl_free_vars in
  let literals =
    Array.to_list (Array.map literal_to_term cl.Clause.cl_litarray) in
  let disjuncted_literals =
    if List.length literals = 0 then mk_false
    else if List.length literals = 1 then List.hd literals
    else
      List.fold_right mk_or
        (List.tl literals
         |> if tr = Experiment then
              (*to emulate current translation*)
              List.rev
            else (fun x -> x))
        (List.hd literals)
  in (string_of_int cl.Clause.cl_number, mk_all free_vars disjuncted_literals)

(*?*)

(*Produce type declaration clauses for inclusion in state's
  fo_clauses field*)
let type_decls ((_, (fmt, _)) as cfg : Translation_general.configuration) (st : State.state) = match fmt with
    TPTP_FOF -> [] (*No declarations necessary in FOF*)
  | TPTP_TFF ->
      let mk_tydecl cfg name symbol ty_s =
        let af_s = print_af_typing cfg name symbol ty_s
        in (name, af_s) in
      let typing_to_typedecl (s, ty) =
        (*Risk of nameclash avoided by uniform prefixing*)
        let s_node_name = prefix_type_af ^ s in
        let s' =
          if ty = Signature.bt_type then
            prefix_type ^ s
          else prefix_const ^ s
        in
          try
            [mk_tydecl cfg s_node_name s' (tff_type_to_string true ty)]
          with
              TYPE ("Cannot convert high-type function into TFF", ty) ->
                State.set_current_success_status None State.GaveUp;
                raise (State.Termination (Some st))
      in
        mk_tydecl cfg (prefix_type_proxy_af ^ proxy_boolK) proxy_boolK (tff_type_to_string false Signature.bt_type) ::
        mk_tydecl cfg (prefix_type_proxy_af ^ pK) pK (tff_type_to_string false pK_ty) ::
        List.fold_right (fun ((n, ty) as typing) l ->
                           (*The signature kept by Leo2 also includes the types of
                             bound variables, but these must not be included among
                             the TFF declarations*)
                           if Translation_general.is_variable n then l
                           else
                             (*simple arrangement to ensure that type declarations
                               precede constant declarations (since the latter might
                               user the former*)
                             if ty = Signature.bt_type then typing_to_typedecl typing @ l
                             else l @ typing_to_typedecl typing)
          (Signature.all_uninterpreted_symbols st.State.signature)
          []


(* Translations *)

(*
Terms are transformed according to the following pipeline. The top pipeline
is more accurate and up to date. The bottom pipeline is legacy and experimental,
and only works for limited FOF encodings. The top pipeline allows much more
sharing of code among translations.

         |
         v
      (term) -> term_to_app_term
        |        |                          (also applied to lifted definitions)
        |        v                         /
        |        (-> proximate -> lift ->)+
        |                                 | -> pK_wrap -> post_adjust_for_tff -> TFF
  tag_term + proximate                    v
        |                                tag_app_term -> pK_wrap -> FOF
        v                                                           ^
  clause_to_term -> term_to_app_term -> lift ----------------------/
*)

let apply_clause_translation ((tr,_) as cfg) pre_lift cl : (string * af) list =
    let af_role = Axiom in
    let collect_formulas ((n, ta), proxies, lifts) =
      let proxy_formula_types =
        if tr <> TFF_Experiment then []
        else
          (*Ordering matters in TFF: declarations and definitions must precede use*)
          List.fold_right
            (fun proxy_s l ->
               try
                 let proxy_s' = proxy_of_symbol proxy_s in
                 let name = prefix_type_proxy_af ^ proxy_s'
                 in
                   Termsystem.type_of (Termsystem.term2xterm (Symbol proxy_s))
                   |> tff_type_to_string true
                   |> (fun ty_s ->
                         l @(*FIXME*)
                           [(name, Typing (name, prefix_const(*FIXME shouldn't be needed at this point*) ^ proxy_s',
                                           ty_s))])
               with
                   TYPE ("Cannot convert high-type function into TFF", _) ->
                     State.set_current_success_status None State.GaveUp;
                     raise (State.Termination None)) proxies [] in
      let proxy_formulas =
        List.map
          (fun proxy_s ->
             let axioms = axioms_for_proxy_of cfg proxy_s
           in
            List.map (fun (proxy_axiom_name, proxy_axiom) ->
                        let name = prefix_def_proxy_af ^ proxy_of_symbol proxy_s ^
                          proxy_axiom_name
                        in
                          (name,
                           (*FIXME proxy axioms should be app_terms to start with*)
                           term_to_appterm cfg false [] proxy_axiom
                          |> mark_quantifiers
                          |> (fun ta -> Formula (name, Proxy, ta))))
              axioms)
          proxies
        |> List.flatten in
      let lift_formula_types =
        if tr <> TFF_Experiment then []
        else
          List.fold_right
            (fun (n, ty, _) l ->
               try
                 let name = prefix_type_lift_af ^ n in
                 let ty_s = tff_type_to_string true ty
                 in l @(*FIXME*) [(name, Typing (name, prefix_const(*FIXME shouldn't be needed at this point*) ^ n,
                                                 ty_s))]
               with
                   TYPE ("Cannot convert high-type function into TFF", _) ->
                     State.set_current_success_status None State.GaveUp;
                     raise (State.Termination None)) lifts [] in
      let lift_formulas =
        List.fold_right
          (fun (n, _, ta) l ->
             try
               l @ [(n, Formula (n, af_role, ta))]
             with
                 APP_TERM ("Higher order quantification", _) ->
                   begin
                     assert (tr = TFF_Experiment);
                     []
                   end) lifts [] in
      let main_fmla =
        try
          [(n, Formula (n, af_role, ta))]
        with
            APP_TERM ("Higher order quantification", _) ->
              begin
                assert (tr = TFF_Experiment);
                []
              end
      in
        proxy_formula_types @
          proxy_formulas @
          lift_formula_types @
          lift_formulas @
          main_fmla
    in
      pre_lift cl
      |> include_lambda_lifts cfg (*also applies proximate to the lifted definitions*)
      |> collect_formulas

(*first step of the transformation process for Experiment
  and ExperimentImproved: these tag inside clauses before
  transforming into the intermediate language*)
let clause_to_fullytagged_FOF ((tr,_) as cfg) cl =
  try
    let transf =
      tag_clause cfg (function _ -> true)             (*apply tagging*)
      @> apfst (clause_to_term cfg)                   (*transform clause ..*)
      @> apfst (apsnd (term_to_appterm cfg false []
                       @> mark_quantifiers))          (* .. to appterm*)
    in
      apply_clause_translation cfg transf cl
  with
      NO_PROXY s as e ->
        if tr = Experiment then
          begin
            Util.sysout 3 ("\n No FOF translation for clause " ^
                             Clause.cl_clause_to_string cl ^ "\t(because of " ^ s ^ ")");
            []
          end
        else raise e

(*first step of the transformation process for
  TFF_Experiment and FOF_Experiment: these transform to
  the intermediate language early, then apply further
  transformations at that level*)
let clause_to_term_and_proximate cfg =
  let pre_transf =
    clause_to_term cfg
    @> apsnd (term_to_appterm cfg false []
              @> mark_quantifiers)
    @> (function (n, t) ->
          let (t', proxies) = proximate cfg true t (*gather proxies; transform term to include them*)
          in ((n, t'), proxies))
  in apply_clause_translation cfg pre_transf


(** Handling polymorphic constants  **)

module StringSet = Set.Make(String)
let list_to_stringset l = List.fold_right StringSet.add l StringSet.empty

(*FIXME check this function -- might be broken*)
let quantify_over_types ta =
  let add_polyvars_to_set set tys =
    List.map Hol_type.get_polyvars tys
    |> List.concat
    |> list_to_stringset
    |> (fun s ->
          StringSet.fold
            StringSet.add
            s
            set) in
  let polymorphic_typings vars =
    add_polyvars_to_set StringSet.empty (List.map snd vars) in
  let rec type_vars acc (ta : app_term) : StringSet.t =
    match ta with
        Var (_, ty)
      | Const (_, ty) ->
          add_polyvars_to_set acc [ty]
      | App (ta1, tas) ->
          List.fold_left
            StringSet.union
            (type_vars acc ta1)
            (List.map (type_vars StringSet.empty) tas)
      | Abs (vars, ta')
      | Quant (_, vars, ta') ->
          StringSet.union (polymorphic_typings vars) (type_vars acc ta') in
  let type_list =
    type_vars StringSet.empty ta
    |> StringSet.elements
    |> List.map
        (fun ty_s ->
           (remove_prefix "1" ty_s, (*FIXME brittle*)
            Signature.bt_type))
  in
    if type_list = [] then ta
    else
      (*quantifiers bind both term and type variables*)
      Quant("!", type_list, ta)


(* Main *)

(*Stores the labels of FO clauses which were sent to the external
  ATP during the previous opportunity*)
let prev_fo_clauses : string list ref = ref []
(*If set to true then it means that the current set of FO clauses is
  identical to that sent to the FO ATP in the past -- therefore we
  shouldn't waste time sending them to the FO ATP again*)
let next_atp_call_is_redundant = ref false
(*This should be called in between problems, to reset the cache*)
let reset_prev_fo_clauses_cache () =
  next_atp_call_is_redundant := false;
  prev_fo_clauses := []

(*Principal function in this module: adding FO clauses to the state*)
let tr_add_fo_clauses (cll : Clause.cl_clause list) (st : State.state) =
  let tr = read_translation st.State.flags.State.fo_translation in

  (*generic driver for translations*)
  let apply_translation pre_process analysis transf =
    let cfg = (tr, List.assoc tr configurations) in
    let fo_clauses =
        List.map pre_process cll
        |> List.concat in
    let current_clauses_labels = List.map fst fo_clauses
    in
      IFDEF DEBUG THEN
        Util.sysout 1 ("previous FO clause labels = " ^
                         String.concat ", " !prev_fo_clauses ^ "\n");
        Util.sysout 1 ("current FO clause labels  = " ^
                         String.concat ", " current_clauses_labels ^ "\n");
      END;
      if current_clauses_labels = !prev_fo_clauses then
        begin
          IFDEF DEBUG THEN
            Util.sysout 1 "Avoided redundant call to ATP";
          END;
          next_atp_call_is_redundant := true
        end
      else
        begin
          prev_fo_clauses := current_clauses_labels;
          next_atp_call_is_redundant := false;

          let analysis_result = analysis fo_clauses in

          let string_of_clauses =
            List.map
              (apsnd (transform_fmla_af
                        (fun x -> x <> Proxy)
                        (transf analysis_result)
                      @> print_af cfg))

          in
            begin
              List.iter
                (*if have already cached FO version of this then don't
                  repeat. This avoids retranslating the dependencies
                  (i.e. lifts) of that formula, and avoids
                  having "ghost" lifted combinators (which aren't used
                  in any formula)*)
                (fun (n, fo_cl) ->
                   (*Proxies might still be duplicated, so weed this out here*)
                   (*FIXME use better structure than lists, to prevent this
                     duplication in the first place*)
                   if not (List.mem_assoc n st.State.fo_clauses_new) then
                     st.State.fo_clauses_new <- (n, fo_cl) :: st.State.fo_clauses_new)
                fo_clauses;

              (*FIXME to avoid redundant work, and clearing fo_clauses, could
                      first check if any monotonicity statuses have changed
                      since the last iteration*)
              st.State.fo_clauses <- [];
              List.iter
                (fun (n, fo_cl) ->
                   if not (List.mem_assoc n st.State.fo_clauses) then
                     st.State.fo_clauses <- (n, fo_cl) :: st.State.fo_clauses)
                (type_decls cfg st);
              st.State.fo_clauses <- st.State.fo_clauses @ string_of_clauses st.State.fo_clauses_new;
            end
        end
  in
    match tr with
        Experiment
      | ExperimentImproved ->
          let cfg = (tr, (TPTP_FOF, FullTypes Tags)) in
            apply_translation
              (clause_to_fullytagged_FOF cfg)
              (fun _ -> ())
              (fun () -> fun x -> x)
      | TFF_Experiment ->
          let cfg = (TFF_Experiment, (TPTP_TFF, NativeTypes))
          in
            apply_translation
              (clause_to_term_and_proximate cfg)
              (fun _ -> ())
              (fun () ->
                 (pK_wrap cfg
                  @> post_adjust_for_tff cfg))
      | FOF_Full
      | FOF_Experiment_Erased
      | FOF_Experiment ->
          let cfg = (FOF_Experiment, (*the other two are variants of FOF_Experiment*)
                     List.assoc tr configurations) in
          let transf pred =
            (*FIXME quantify_over_types is broken?*)
            ((* quantify_over_types
              @>*) tag_app_term cfg pred true
              @> pK_wrap cfg) in
          let type_pred =
            match tr with
                FOF_Experiment -> Monotonicity.analysis st
              | FOF_Experiment_Erased -> (fun _ -> fun _ -> false)
              | FOF_Full -> (fun _ -> fun _ -> true)
              | _ -> raise (TRANSLATION "Unexpected value")
          in
            apply_translation
              (clause_to_term_and_proximate cfg)
              type_pred
              transf
      | _ ->
          (*Try one of the old translations*)
          Main.add_fo_clauses cll st

let exc_printers exc =
  match exc with
      APP_TERM (s, ta) -> Some ("APP_TERM (" ^ s ^ ", " ^ app_term_to_string ta ^ ")")
    | TERM (s, t) -> Some ("TERM (" ^ s ^ ", " ^ Term.to_string t ^ ")")
    | TYPE (s, ty) -> Some ("TYPE (" ^ s ^ ", " ^ Hol_type.to_string ty ^ ")")
    | NO_PROXY s -> Some ("NO_PROXY (" ^ s ^ ")")
    | TRANSLATION s -> Some ("TRANSLATION (" ^ s ^ ")")
    | _ -> None
